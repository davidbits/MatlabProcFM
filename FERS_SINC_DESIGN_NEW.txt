packages/libfers/src/signal/dsp_filters.cpp
// SPDX-License-Identifier: GPL-2.0-only
//
// Copyright (c) 2007-2008 Marc Brooker and Michael Inggs
// Copyright (c) 2008-present FERS Contributors (see AUTHORS.md).
//
// See the GNU GPLv2 LICENSE file in the FERS project root for more information.

/**
 * @file dsp_filters.cpp
 * @brief Implementation file for Digital Signal Processing (DSP) filters and upsampling/downsampling functionality.
 */

#include "dsp_filters.h"

#include <algorithm>
#include <array>
#include <cmath>
#include <complex>
#include <numeric>
#include <stdexcept>

#include "core/parameters.h"

constexpr RealType BLACKMAN_A0 = 0.42;
constexpr RealType BLACKMAN_A1 = 0.5;
constexpr RealType BLACKMAN_A2 = 0.08;

namespace
{
	/**
	 * @brief Sinc function for FIR filter design.
	 *
	 * @param x Input value.
	 * @return Sinc value at x.
	 */
	constexpr RealType sinc(const RealType x) noexcept { return x == 0 ? 1.0 : std::sin(x * PI) / (x * PI); }

	/**
	 * @brief Generates FIR filter coefficients using the Blackman window.
	 *
	 * @param cutoff Cutoff frequency for the filter.
	 * @param filtLength Length of the filter.
	 * @return Vector of FIR filter coefficients.
	 */
	std::vector<RealType> blackmanFir(const RealType cutoff, unsigned& filtLength) noexcept
	{
		filtLength = params::renderFilterLength() * 2;
		std::vector<RealType> coeffs(filtLength);
		const RealType n = filtLength / 2.0;
		const RealType pi_n = PI / n;

		// We use the Blackman window, for a suitable tradeoff between rolloff and stopband attenuation
		// Equivalent Kaiser beta = 7.04 (Oppenhiem and Schaffer, Hamming)
		std::ranges::for_each(coeffs,
							  [cutoff, n, pi_n, i = 0u](RealType& coeff) mutable
							  {
								  const RealType sinc_val = sinc(cutoff * (i - n));
								  const RealType window = BLACKMAN_A0 - BLACKMAN_A1 * std::cos(pi_n * i) +
									  BLACKMAN_A2 * std::cos(2 * pi_n * i);
								  coeff = sinc_val * window;
								  ++i;
							  });

		return coeffs;
	}
}

namespace fers_signal
{
	void upsample(const std::span<const ComplexType> in, const unsigned size, std::span<ComplexType> out)
	{
		const unsigned ratio = params::oversampleRatio();
		// TODO: this would be better as a multirate upsampler
		// This implementation is functional but suboptimal.
		// Users requiring higher accuracy should oversample outside FERS until this is addressed.
		unsigned filt_length;
		const auto coeffs = blackmanFir(1 / static_cast<RealType>(ratio), filt_length);

		std::vector tmp(size * ratio + filt_length, ComplexType{0.0, 0.0});

		for (unsigned i = 0; i < size; ++i)
		{
			tmp[i * ratio] = in[i];
		}

		const FirFilter filt(coeffs);
		filt.filter(tmp);

		const auto delay = filt_length / 2 - 1;
		std::ranges::copy_n(tmp.begin() + delay, size * ratio, out.begin());
	}

	std::vector<ComplexType> downsample(std::span<const ComplexType> in)
	{
		if (in.empty())
		{
			throw std::invalid_argument("Input span is empty in Downsample");
		}

		const unsigned ratio = params::oversampleRatio();
		// TODO: Replace with a more efficient multirate downsampling implementation.
		unsigned filt_length = 0;
		const auto coeffs = blackmanFir(1 / static_cast<RealType>(ratio), filt_length);

		std::vector tmp(in.size() + filt_length, ComplexType{0, 0});

		std::ranges::copy(in, tmp.begin());

		const FirFilter filt(coeffs);
		filt.filter(tmp);

		const auto downsampled_size = in.size() / ratio;
		std::vector<ComplexType> out(downsampled_size);
		for (unsigned i = 0; i < downsampled_size; ++i)
		{
			out[i] = tmp[i * ratio + filt_length / 2] / static_cast<RealType>(ratio);
		}

		return out;
	}

	IirFilter::IirFilter(const RealType* denCoeffs, const RealType* numCoeffs, const unsigned order) noexcept :
		_a(denCoeffs, denCoeffs + order), _b(numCoeffs, numCoeffs + order), _w(order, 0.0), _order(order)
	{
	}

	RealType IirFilter::filter(const RealType sample) noexcept
	{
		std::ranges::rotate(_w, _w.end() - 1);

		_w[0] = sample;

		for (unsigned j = 1; j < _order; ++j)
		{
			_w[0] -= _a[j] * _w[j];
		}

		return std::inner_product(_b.begin(), _b.end(), _w.begin(), 0.0);
	}

	void IirFilter::filter(std::span<RealType> samples) noexcept
	{
		for (auto& sample : samples)
		{
			std::ranges::rotate(_w, _w.end() - 1);

			_w[0] = sample;

			for (unsigned j = 1; j < _order; ++j)
			{
				_w[0] -= _a[j] * _w[j];
			}

			sample = std::inner_product(_b.begin(), _b.end(), _w.begin(), 0.0);
		}
	}

	void FirFilter::filter(std::vector<ComplexType>& samples) const
	{
		std::vector line(_order, ComplexType{0.0, 0.0});

		for (auto& sample : samples)
		{
			line[0] = sample;
			ComplexType result{0.0, 0.0};

			result = std::transform_reduce(line.rbegin(), line.rend(), _filter.begin(), ComplexType{0.0, 0.0},
										   std::plus<ComplexType>{},
										   [](const ComplexType& x, const RealType coeff) { return x * coeff; });

			sample = result;

			std::rotate(line.rbegin(), line.rbegin() + 1, line.rend());
		}
	}

	DecadeUpsampler::DecadeUpsampler()
	{
		/// 11th order elliptic lowpass at 0.1fs
		constexpr std::array den_coeffs = {1.0,
										   -10.301102119865,
										   48.5214567642597,
										   -137.934509572412,
										   262.914952985445,
										   -352.788381841481,
										   340.027874008585,
										   -235.39260470286,
										   114.698499845697,
										   -37.4634653062448,
										   7.38208765922137,
										   -0.664807695826097};

		constexpr std::array num_coeffs = {2.7301694322809e-06,	  -1.8508123430239e-05,	 5.75739466753894e-05,
										   -0.000104348734423658, 0.000111949190289715,	 -4.9384188225528e-05,
										   -4.9384188225522e-05,  0.00011194919028971,	 -0.000104348734423656,
										   5.75739466753884e-05,  -1.85081234302388e-05, 2.73016943228086e-06};

		_filter = std::make_unique<IirFilter>(den_coeffs.data(), num_coeffs.data(), den_coeffs.size());
	}

	void DecadeUpsampler::upsample(const RealType sample, std::span<RealType> out) const
	{
		if (out.size() != 10)
		{
			throw std::invalid_argument("Output span must have a size of 10.");
		}
		out[0] = sample;
		std::fill(out.begin() + 1, out.end(), 0);
		_filter->filter(out);
	}
}


packages/libfers/src/interpolation/interpolation_filter.h
// SPDX-License-Identifier: GPL-2.0-only
//
// Copyright (c) 2006-2008 Marc Brooker and Michael Inggs
// Copyright (c) 2008-present FERS Contributors (see AUTHORS.md).
//
// See the GNU GPLv2 LICENSE file in the FERS project root for more information.

/**
 * @file interpolation_filter.h
 * @brief Interpolation filter implementation using Kaiser windowing.
 */

#pragma once

#include <expected>
#include <span>
#include <vector>

#include "core/config.h"

namespace interp
{
	/**
	 * @class InterpFilter
	 * @brief Provides methods to generate interpolation filters using Kaiser windows.
	 */
	class InterpFilter
	{
	public:
		InterpFilter(const InterpFilter&) = delete;
		InterpFilter(InterpFilter&&) = delete;
		InterpFilter& operator=(const InterpFilter&) = delete;
		InterpFilter& operator=(InterpFilter&&) = delete;
		~InterpFilter() = default;

		/**
		 * @brief Computes the sinc function for a given input.
		 *
		 * @param x The input value for which the sinc function is computed.
		 * @return The computed sinc value.
		 */
		static constexpr RealType sinc(const RealType x) noexcept
		{
			return x == 0.0 ? 1.0 : std::sin(x * PI) / (x * PI);
		}

		/**
		 * @brief Computes the Kaiser window function for a given input.
		 *
		 * @param x The input value for the Kaiser window calculation.
		 * @return The computed window value, or an error message if computation fails.
		 */
		[[nodiscard]] std::expected<RealType, std::string> kaiserWinCompute(RealType x) const noexcept;

		/**
		 * @brief Computes the interpolation filter value for a given input.
		 *
		 * @param x The input value for which the interpolation filter is computed.
		 * @return The computed filter value, or an error message if computation fails.
		 */
		[[nodiscard]] std::expected<RealType, std::string> interpFilter(RealType x) const noexcept;

		/**
		 * @brief Retrieves a span of precomputed filter values for a given delay.
		 *
		 * @param delay The delay value for which the filter is retrieved.
		 * @return A span of precomputed filter values.
		 * @throws std::runtime_error If the delay value is out of range.
		 */
		[[nodiscard]] std::span<const RealType> getFilter(RealType delay) const;

		/**
		 * @brief Retrieves the singleton instance of the `InterpFilter` class.
		 *
		 * @return The singleton instance of the `InterpFilter` class.
		 */
		static InterpFilter& getInstance() noexcept;

	private:
		InterpFilter(); ///< Private constructor to prevent instantiation.

		RealType _alpha; ///< The alpha value for the Kaiser window.
		RealType _beta = 5; ///< The beta value for the Kaiser window.
		RealType _bessel_beta; ///< The Bessel function value for the Kaiser window.
		int _length; ///< The length of the filter.
		int _table_filters; ///< The number of filters in the table.
		std::vector<RealType> _filter_table; ///< The table of precomputed filters.
	};
}


packages/libfers/src/interpolation/interpolation_filter.cpp
// SPDX-License-Identifier: GPL-2.0-only
//
// Copyright (c) 2006-2008 Marc Brooker and Michael Inggs
// Copyright (c) 2008-present FERS Contributors (see AUTHORS.md).
//
// See the GNU GPLv2 LICENSE file in the FERS project root for more information.

/**
 * @file interpolation_filter.cpp
 * @brief Implementation of the InterpFilter class.
 */

#include "interpolation_filter.h"

#include <stdexcept>

#include "core/logging.h"
#include "core/parameters.h"

using logging::Level;

namespace
{
	/**
	 * @brief Computes the modified Bessel function of the first kind for x.
	 *
	 * @param x The input value for which the Bessel function is computed.
	 * @return The computed Bessel function value, or an error message if computation fails.
	 */
	std::expected<RealType, std::string> besselI0(const RealType x)
	{
		// Use the polynomial approximation from section 9.8 of
		// "Handbook of Mathematical Functions" by Abramowitz and Stegun
		if (x < 0.0)
		{
			return std::unexpected("Modified Bessel approximation only valid for x > 0");
		}
		if (RealType t = x / 3.75; t <= 1.0)
		{
			t *= t;
			return 1.0 +
				t * (3.5156229 + t * (3.0899424 + t * (1.2067492 + t * (0.2659732 + t * (0.0360768 + t * 0.0045813)))));
		}
		else
		{
			const RealType i0 = 0.39894228 +
				t *
					(0.01328592 +
					 t *
						 (0.00225319 +
						  t *
							  (-0.00157565 +
							   t *
								   (0.00916281 +
									t * (-0.02057706 + t * (0.02635537 + t * (-0.01647633 + t * 0.00392377)))))));
			return i0 * std::exp(x) / std::sqrt(x);
		}
	}
}

namespace interp
{
	InterpFilter& InterpFilter::getInstance() noexcept
	{
		static InterpFilter instance;
		return instance;
	}

	std::expected<RealType, std::string> InterpFilter::kaiserWinCompute(const RealType x) const noexcept
	{
		if (x < 0 || x > _alpha * 2)
		{
			return 0;
		}
		if (auto bessel = besselI0(_beta * std::sqrt(1 - std::pow((x - _alpha) / _alpha, 2))); bessel)
		{
			return *bessel / _bessel_beta;
		}
		else
		{
			return std::unexpected(bessel.error());
		}
	}

	std::expected<RealType, std::string> InterpFilter::interpFilter(const RealType x) const noexcept
	{
		if (auto kaiser = kaiserWinCompute(x + _alpha); kaiser)
		{
			return *kaiser * sinc(x);
		}
		else
		{
			return std::unexpected(kaiser.error());
		}
	}

	InterpFilter::InterpFilter()
	{
		_length = static_cast<int>(params::renderFilterLength());
		_table_filters = 1000;
		_filter_table = std::vector<RealType>(_table_filters * _length);

		_alpha = std::floor(params::renderFilterLength() / 2.0);
		if (auto bessel = besselI0(_beta); bessel)
		{
			_bessel_beta = *bessel;
		}
		else
		{
			LOG(Level::FATAL, "Bessel function calculation failed: {}", bessel.error());
			throw std::runtime_error("Bessel function calculation failed");
		}

		const int hfilt = _table_filters / 2;

		LOG(Level::DEBUG, "Building table of {} filters", _table_filters);

		for (int i = -hfilt; i < hfilt; ++i)
		{
			const RealType delay = i / static_cast<RealType>(hfilt);
			for (int j = static_cast<int>(-_alpha); j < _alpha; ++j)
			{
				if (auto interp = interpFilter(j - delay); interp)
				{
					_filter_table[(i + hfilt) * _length + j + static_cast<int>(_alpha)] = *interp;
				}
				else
				{
					LOG(Level::FATAL, "Interpolation filter calculation failed: {}", interp.error());
					throw std::runtime_error("Interpolation filter calculation failed");
				}
			}
		}

		LOG(Level::DEBUG, "Filter table complete");
	}

	std::span<const RealType> InterpFilter::getFilter(RealType delay) const
	{
		if (delay < -1 || delay > 1)
		{
			LOG(Level::FATAL, "Requested delay filter value out of range: {}", delay);
			throw std::runtime_error("Requested delay filter value out of range");
		}

		const auto filt = static_cast<unsigned>((delay + 1) * (_table_filters / 2.0));
		return std::span{&_filter_table[filt * _length], static_cast<size_t>(_length)};
	}
}


packages/libfers/src/antenna/antenna_factory.h
// SPDX-License-Identifier: GPL-2.0-only
//
// Copyright (c) 2006-2008 Marc Brooker and Michael Inggs
// Copyright (c) 2008-present FERS Contributors (see AUTHORS.md).
//
// See the GNU GPLv2 LICENSE file in the FERS project root for more information.

/**
 * @file antenna_factory.h
 * @brief Header file defining various types of antennas and their gain patterns.
 */

#pragma once

#include <memory>
#include <string>
#include <string_view>
#include <utility>
#include <vector>

#include "core/config.h"
#include "core/logging.h"
#include "interpolation/interpolation_set.h"
#include "math/geometry_ops.h"

namespace serial
{
	std::vector<std::vector<RealType>> readPattern(const std::string& name, const std::string& datasetName);
}

namespace antenna
{
	/**
	 * @class Antenna
	 * @brief Abstract base class representing an antenna.
	 */
	class Antenna
	{
	public:
		/**
		 * @brief Constructs an Antenna object with the given name.
		 *
		 * @param name The name of the antenna.
		 */
		explicit Antenna(std::string name) noexcept : _loss_factor(1), _name(std::move(name)) {}

		virtual ~Antenna() = default;

		Antenna(const Antenna&) = delete;

		Antenna& operator=(const Antenna&) = delete;

		Antenna(Antenna&&) = default;

		Antenna& operator=(Antenna&&) = default;

		/**
		 * @brief Computes the gain of the antenna based on the input angle and reference angle.
		 *
		 * @param angle The angle at which the gain is to be computed.
		 * @param refangle The reference angle.
		 * @param wavelength The wavelength of the signal.
		 * @return The gain of the antenna at the specified angle and wavelength.
		 */
		[[nodiscard]] virtual RealType getGain(const math::SVec3& angle, const math::SVec3& refangle,
											   RealType wavelength) const = 0;

		/**
		 * @brief Retrieves the efficiency factor of the antenna.
		 *
		 * @return The efficiency factor of the antenna.
		 */
		[[nodiscard]] RealType getEfficiencyFactor() const noexcept { return _loss_factor; }

		/**
		 * @brief Retrieves the name of the antenna.
		 *
		 * @return The name of the antenna.
		 */
		[[nodiscard]] std::string getName() const noexcept { return _name; }

		/**
		 * @brief Computes the noise temperature of the antenna based on the angle.
		 *
		 * @param angle The angle at which the noise temperature is to be computed.
		 * @return The noise temperature of the antenna.
		 */
		// TODO: Implement noise temperature calculation
		[[nodiscard]] virtual RealType getNoiseTemperature(const math::SVec3& /*angle*/) const noexcept { return 0; }

		/**
		 * @brief Sets the efficiency factor of the antenna.
		 *
		 * @param loss The new efficiency factor.
		 */
		void setEfficiencyFactor(RealType loss) noexcept;

	protected:
		/**
		 * @brief Computes the angle between the input and reference angles.
		 *
		 * @param angle The input angle.
		 * @param refangle The reference angle.
		 * @return The computed angle.
		 */
		static RealType getAngle(const math::SVec3& angle, const math::SVec3& refangle) noexcept;

	private:
		RealType _loss_factor; ///< Efficiency factor of the antenna.
		std::string _name; ///< Name of the antenna.
	};

	/**
	 * @class Isotropic
	 * @brief Represents an isotropic antenna with uniform gain in all directions.
	 *
	 * This class models an ideal isotropic antenna, which has a directivity of 1 (0 dB).
	 */
	class Isotropic final : public Antenna
	{
	public:
		/**
		 * @brief Constructs an Isotropic antenna with the given name.
		 *
		 * @param name The name of the antenna.
		 */
		explicit Isotropic(const std::string_view name) : Antenna(name.data()) {}

		~Isotropic() override = default;

		Isotropic(const Isotropic&) = delete;

		Isotropic& operator=(const Isotropic&) = delete;

		Isotropic(Isotropic&&) = delete;

		Isotropic& operator=(Isotropic&&) = delete;

		/**
		 * @brief Computes the gain of the isotropic antenna.
		 *
		 * @return The gain of the antenna, which is equal to the efficiency factor.
		 */
		[[nodiscard]] RealType getGain(const math::SVec3& /*angle*/, const math::SVec3& /*refangle*/,
									   RealType /*wavelength*/) const override
		{
			// David Young: Isotropic antennas have a directivity of 1 (or 0 dB),
			// therefore, the gain of the antenna is the efficiency factor
			return getEfficiencyFactor();
		}
	};

	/**
	 * @class Sinc
	 * @brief Represents a sinc function-based antenna gain pattern.
	 *
	 * This antenna has a gain pattern defined by a sinc function, with customizable parameters.
	 */
	class Sinc final : public Antenna
	{
	public:
		/**
		 * @brief Constructs a Sinc antenna with the given parameters.
		 *
		 * @param name The name of the antenna.
		 * @param alpha The alpha parameter.
		 * @param beta The beta parameter.
		 * @param gamma The gamma parameter.
		 */
		Sinc(const std::string_view name, const RealType alpha, const RealType beta, const RealType gamma) :
			Antenna(name.data()), _alpha(alpha), _beta(beta), _gamma(gamma)
		{
		}

		~Sinc() override = default;

		Sinc(const Sinc&) = delete;

		Sinc& operator=(const Sinc&) = delete;

		Sinc(Sinc&&) = delete;

		Sinc& operator=(Sinc&&) = delete;

		/** @brief Gets the alpha parameter of the sinc function. */
		[[nodiscard]] RealType getAlpha() const noexcept { return _alpha; }

		/** @brief Gets the beta parameter of the sinc function. */
		[[nodiscard]] RealType getBeta() const noexcept { return _beta; }

		/** @brief Gets the gamma parameter of the sinc function. */
		[[nodiscard]] RealType getGamma() const noexcept { return _gamma; }

		/**
		 * @brief Computes the gain of the sinc antenna based on the input parameters.
		 *
		 * @param angle The angle at which the gain is to be computed.
		 * @param refangle The reference angle.
		 * @param wavelength The wavelength of the signal.
		 * @return The computed gain of the antenna.
		 */
		[[nodiscard]] RealType getGain(const math::SVec3& angle, const math::SVec3& refangle,
									   RealType wavelength) const noexcept override;

	private:
		RealType _alpha; ///< Parameter defining the shape of the gain pattern.
		RealType _beta; ///< Parameter defining the shape of the gain pattern.
		RealType _gamma; ///< Parameter defining the shape of the gain pattern.
	};

	/**
	 * @class Gaussian
	 * @brief Represents a Gaussian-shaped antenna gain pattern.
	 *
	 * This antenna has a gain pattern that follows a Gaussian distribution.
	 */
	class Gaussian final : public Antenna
	{
	public:
		/**
		 * @brief Constructs a Gaussian antenna with the given parameters.
		 *
		 * @param name The name of the antenna.
		 * @param azscale The azimuth scale factor.
		 * @param elscale The elevation scale factor.
		 */
		Gaussian(const std::string_view name, const RealType azscale, const RealType elscale) :
			Antenna(name.data()), _azscale(azscale), _elscale(elscale)
		{
		}

		~Gaussian() override = default;

		Gaussian(const Gaussian&) = delete;

		Gaussian& operator=(const Gaussian&) = delete;

		Gaussian(Gaussian&&) = delete;

		Gaussian& operator=(Gaussian&&) = delete;

		/**
		 * @brief Computes the gain of the Gaussian antenna.
		 *
		 * @param angle The angle at which the gain is to be computed.
		 * @param refangle The reference angle.
		 * @param wavelength The wavelength of the signal.
		 * @return The computed gain of the antenna.
		 */
		[[nodiscard]] RealType getGain(const math::SVec3& angle, const math::SVec3& refangle,
									   RealType wavelength) const noexcept override;

		/** @brief Gets the azimuth scale factor. */
		[[nodiscard]] RealType getAzimuthScale() const noexcept { return _azscale; }

		/** @brief Gets the elevation scale factor. */
		[[nodiscard]] RealType getElevationScale() const noexcept { return _elscale; }

	private:
		RealType _azscale; ///< Azimuth scale factor.
		RealType _elscale; ///< Elevation scale factor.
	};

	/**
	 * @class SquareHorn
	 * @brief Represents a square horn antenna.
	 *
	 * This antenna models a square horn with a specific dimension.
	 */
	class SquareHorn final : public Antenna
	{
	public:
		/**
		 * @brief Constructs a SquareHorn antenna with the given dimension.
		 *
		 * @param name The name of the antenna.
		 * @param dimension The dimension of the square horn.
		 */
		SquareHorn(const std::string_view name, const RealType dimension) : Antenna(name.data()), _dimension(dimension)
		{
		}

		~SquareHorn() override = default;

		SquareHorn(const SquareHorn&) = delete;

		SquareHorn& operator=(const SquareHorn&) = delete;

		SquareHorn(SquareHorn&&) = delete;

		SquareHorn& operator=(SquareHorn&&) = delete;

		/**
		 * @brief Computes the gain of the square horn antenna.
		 *
		 * @param angle The angle at which the gain is to be computed.
		 * @param refangle The reference angle.
		 * @param wavelength The wavelength of the signal.
		 * @return The computed gain of the antenna.
		 */
		[[nodiscard]] RealType getGain(const math::SVec3& angle, const math::SVec3& refangle,
									   RealType wavelength) const noexcept override;

		/** @brief Gets the dimension of the square horn. */
		[[nodiscard]] RealType getDimension() const noexcept { return _dimension; }

	private:
		RealType _dimension; ///< Dimension of the square horn.
	};

	/**
	 * @class Parabolic
	 * @brief Represents a parabolic reflector antenna.
	 *
	 * This antenna models a parabolic reflector with a specific diameter.
	 */
	class Parabolic final : public Antenna
	{
	public:
		/**
		 * @brief Constructs a Parabolic antenna with the given diameter.
		 *
		 * @param name The name of the antenna.
		 * @param diameter The diameter of the parabolic reflector.
		 */
		Parabolic(const std::string_view name, const RealType diameter) : Antenna(name.data()), _diameter(diameter) {}

		~Parabolic() override = default;

		Parabolic(const Parabolic&) = delete;

		Parabolic& operator=(const Parabolic&) = delete;

		Parabolic(Parabolic&&) = delete;

		Parabolic& operator=(Parabolic&&) = delete;

		/**
		 * @brief Computes the gain of the parabolic antenna.
		 *
		 * @param angle The angle at which the gain is to be computed.
		 * @param refangle The reference angle.
		 * @param wavelength The wavelength of the signal.
		 * @return The computed gain of the antenna.
		 */
		[[nodiscard]] RealType getGain(const math::SVec3& angle, const math::SVec3& refangle,
									   RealType wavelength) const noexcept override;

		/** @brief Gets the diameter of the parabolic reflector. */
		[[nodiscard]] RealType getDiameter() const noexcept { return _diameter; }

	private:
		RealType _diameter; ///< Diameter of the parabolic reflector.
	};

	/**
	 * @class XmlAntenna
	 * @brief Represents an antenna whose gain pattern is defined by an XML file.
	 *
	 * This class models an antenna where the gain pattern is read from an XML file.
	 */
	class XmlAntenna final : public Antenna
	{
	public:
		/**
		 * @brief Constructs an XmlAntenna with the specified name and XML configuration file.
		 *
		 * The constructor loads the azimuth and elevation gain patterns from the provided XML file.
		 *
		 * @param name The name of the antenna.
		 * @param filename The path to the XML file containing the antenna's gain pattern data.
		 */
		XmlAntenna(const std::string_view name, const std::string_view filename) :
			Antenna(name.data()), _azi_samples(std::make_unique<interp::InterpSet>()),
			_elev_samples(std::make_unique<interp::InterpSet>())
		{
			loadAntennaDescription(filename);
		}

		~XmlAntenna() override = default;

		XmlAntenna(const XmlAntenna&) = delete;

		XmlAntenna& operator=(const XmlAntenna&) = delete;

		XmlAntenna(XmlAntenna&&) = delete;

		XmlAntenna& operator=(XmlAntenna&&) = delete;

		/**
		 * @brief Computes the gain of the antenna based on the input angle and reference angle.
		 *
		 * @param angle The angle at which the gain is to be computed.
		 * @param refangle The reference angle.
		 * @param wavelength The wavelength of the signal (not used in this antenna type).
		 * @return The gain of the antenna at the specified angle.
		 * @throws std::runtime_error If gain values cannot be retrieved from the interpolation sets.
		 */
		[[nodiscard]] RealType getGain(const math::SVec3& angle, const math::SVec3& refangle,
									   RealType wavelength) const override;

		/** @brief Gets the filename of the antenna description. */
		[[nodiscard]] const std::string& getFilename() const noexcept { return _filename; }

		/** @brief Gets the maximum gain of the antenna. */
		[[nodiscard]] RealType getMaxGain() const noexcept { return _max_gain; }

		/** @brief Gets the interpolation set for azimuth gain samples. */
		[[nodiscard]] const interp::InterpSet* getAzimuthSamples() const noexcept { return _azi_samples.get(); }

		/** @brief Gets the interpolation set for elevation gain samples. */
		[[nodiscard]] const interp::InterpSet* getElevationSamples() const noexcept { return _elev_samples.get(); }

	private:
		/**
		 * @brief Loads the antenna gain pattern from the specified XML file.
		 *
		 * @param filename The path to the XML file containing the antenna's gain pattern data.
		 * @throws std::runtime_error If the XML file cannot be loaded or parsed.
		 */
		void loadAntennaDescription(std::string_view filename);

		std::string _filename; ///< The original filename for the antenna description.
		RealType _max_gain{}; ///< The maximum gain of the antenna.
		std::unique_ptr<interp::InterpSet> _azi_samples; ///< Interpolation set for azimuth gain samples.
		std::unique_ptr<interp::InterpSet> _elev_samples; ///< Interpolation set for elevation gain samples.
	};

	/**
	 * @class H5Antenna
	 * @brief Represents an antenna whose gain pattern is loaded from a HDF5 file.
	 *
	 * This class models an antenna with a gain pattern defined in an HDF5 file. The gain pattern is stored in a
	 * `Pattern` object, which is used to compute the antenna's gain based on the input angle and reference angle.
	 */
	class H5Antenna final : public Antenna
	{
	public:
		/**
		 * @brief Constructs a H5Antenna with the specified name and gain pattern file.
		 *
		 * @param name The name of the antenna.
		 * @param filename The path to the file containing the antenna's gain pattern.
		 */
		H5Antenna(const std::string_view name, const std::string& filename) :
			Antenna(name.data()), _pattern(serial::readPattern(filename, "antenna")), _filename(filename)
		{
		}

		~H5Antenna() override = default;

		H5Antenna(const H5Antenna&) = delete;

		H5Antenna& operator=(const H5Antenna&) = delete;

		H5Antenna(H5Antenna&&) = delete;

		H5Antenna& operator=(H5Antenna&&) = delete;

		/**
		 * @brief Computes the gain of the antenna based on the input angle and reference angle.
		 *
		 * @param angle The angle at which the gain is to be computed.
		 * @param refangle The reference angle.
		 * @return The gain of the antenna at the specified angle.
		 */
		[[nodiscard]] RealType getGain(const math::SVec3& angle, const math::SVec3& refangle,
									   RealType /*wavelength*/) const override;

		/** @brief Gets the filename of the antenna description. */
		[[nodiscard]] const std::string& getFilename() const noexcept { return _filename; }

		/** @brief Gets the gain pattern object. */
		[[nodiscard]] const std::vector<std::vector<RealType>>& getPattern() const noexcept { return _pattern; }

	private:
		std::vector<std::vector<RealType>> _pattern; ///< The 2D pattern data.
		std::string _filename; ///< The original filename for the antenna description.
	};
}


packages/libfers/src/antenna/antenna_factory.cpp
// SPDX-License-Identifier: GPL-2.0-only
//
// Copyright (c) 2006-2008 Marc Brooker and Michael Inggs
// Copyright (c) 2008-present FERS Contributors (see AUTHORS.md).
//
// See the GNU GPLv2 LICENSE file in the FERS project root for more information.

/**
 * @file antenna_factory.cpp
 * @brief Implementation of the Antenna class and its derived classes.
 */

#include "antenna/antenna_factory.h"

#include <algorithm>
#include <cmath>
#include <complex>
#include <optional>
#include <stdexcept>

#include "core/config.h"
#include "core/logging.h"
#include "core/portable_utils.h"
#include "math/geometry_ops.h"
#include "serial/libxml_wrapper.h"

using logging::Level;
using math::SVec3;
using math::Vec3;

namespace
{
	/**
	 * @brief Compute the sinc function.
	 *
	 * @param theta The angle for which to compute the sinc function.
	 * @return The value of the sinc function at the given angle theta.
	 */
	RealType sinc(const RealType theta) noexcept
	{
		if (std::abs(theta) < EPSILON)
		{
			return 1.0;
		}
		return std::sin(theta) / theta;
	}

	/**
	 * @brief Compute the Bessel function of the first kind.
	 *
	 * @param x The value for which to compute the Bessel function.
	 * @return The value of the Bessel function of the first kind at the given value x.
	 */
	RealType j1C(const RealType x) noexcept { return x == 0 ? 1.0 : core::besselJ1(x) / x; }

	/**
	 * @brief Load antenna gain axis data from an XML element.
	 *
	 * @param set The interpolation set to store the gain axis data.
	 * @param axisXml The XML element containing the gain axis data.
	 */
	void loadAntennaGainAxis(const interp::InterpSet* set, const XmlElement& axisXml) noexcept
	{
		XmlElement tmp = axisXml.childElement("gainsample");
		while (tmp.isValid())
		{
			XmlElement angle_element = tmp.childElement("angle", 0);

			if (XmlElement gain_element = tmp.childElement("gain", 0);
				angle_element.isValid() && gain_element.isValid())
			{
				const RealType angle = std::stof(angle_element.getText());
				const RealType gain = std::stof(gain_element.getText());
				set->insertSample(angle, gain);
			}

			tmp = XmlElement(tmp.getNode()->next);
		}
	}
}

namespace antenna
{
	void Antenna::setEfficiencyFactor(const RealType loss) noexcept
	{
		if (loss > 1)
		{
			LOG(Level::INFO, "Using greater than unity antenna efficiency.");
		}
		_loss_factor = loss;
	}

	RealType Antenna::getAngle(const SVec3& angle, const SVec3& refangle) noexcept
	{
		SVec3 normangle(angle);
		normangle.length = 1;
		return std::acos(dotProduct(Vec3(normangle), Vec3(refangle)));
	}

	RealType Gaussian::getGain(const SVec3& angle, const SVec3& refangle, RealType /*wavelength*/) const noexcept
	{
		const SVec3 a = angle - refangle;
		return std::exp(-a.azimuth * a.azimuth * _azscale) * std::exp(-a.elevation * a.elevation * _elscale);
	}

	RealType Sinc::getGain(const SVec3& angle, const SVec3& refangle, RealType /*wavelength*/) const noexcept
	{
		const RealType theta = getAngle(angle, refangle);
		const RealType sinc_val = sinc(_beta * theta);
		const RealType gain_pattern = std::pow(std::abs(sinc_val), _gamma);
		return _alpha * gain_pattern * getEfficiencyFactor();
	}

	RealType SquareHorn::getGain(const SVec3& angle, const SVec3& refangle, const RealType wavelength) const noexcept
	{
		const RealType ge = 4 * PI * std::pow(_dimension, 2) / std::pow(wavelength, 2);
		const RealType x = PI * _dimension * std::sin(getAngle(angle, refangle)) / wavelength;
		return ge * std::pow(sinc(x), 2) * getEfficiencyFactor();
	}

	RealType Parabolic::getGain(const SVec3& angle, const SVec3& refangle, const RealType wavelength) const noexcept
	{
		const RealType ge = std::pow(PI * _diameter / wavelength, 2);
		const RealType x = PI * _diameter * std::sin(getAngle(angle, refangle)) / wavelength;
		return ge * std::pow(2 * j1C(x), 2) * getEfficiencyFactor();
	}

	RealType XmlAntenna::getGain(const SVec3& angle, const SVec3& refangle, RealType /*wavelength*/) const
	{
		const SVec3 delta_angle = angle - refangle;

		const std::optional<RealType> azi_value = _azi_samples->getValueAt(std::abs(delta_angle.azimuth));

		if (const std::optional<RealType> elev_value = _elev_samples->getValueAt(std::abs(delta_angle.elevation));
			azi_value && elev_value)
		{
			return *azi_value * *elev_value * _max_gain * getEfficiencyFactor();
		}

		LOG(Level::FATAL, "Could not get antenna gain value");
		throw std::runtime_error("Could not get antenna gain value");
	}

	void XmlAntenna::loadAntennaDescription(const std::string_view filename)
	{
		_filename = filename;
		XmlDocument doc;
		if (!doc.loadFile(std::string(filename)))
		{
			LOG(Level::FATAL, "Could not load antenna description {}", filename.data());
			throw std::runtime_error("Could not load antenna description");
		}

		const XmlElement root(doc.getRootElement());
		loadAntennaGainAxis(_elev_samples.get(), root.childElement("elevation", 0));
		loadAntennaGainAxis(_azi_samples.get(), root.childElement("azimuth", 0));

		_max_gain = std::max(_azi_samples->getMax(), _elev_samples->getMax());
		_elev_samples->divide(_max_gain);
		_azi_samples->divide(_max_gain);
	}

	RealType H5Antenna::getGain(const SVec3& angle, const SVec3& refangle, RealType /*wavelength*/) const
	{
		constexpr RealType two_pi = 2.0 * PI;

		const SVec3& pattern_angle = angle - refangle;

		const double ex1 = (pattern_angle.azimuth + PI) / two_pi;
		const double ey1 = (pattern_angle.elevation + PI) / two_pi;

		const auto calc_grid_point = [](const double value, const unsigned size)
		{
			const double x1 = std::floor(value * (size - 1)) / (size - 1);
			const double x2 = std::min(x1 + 1.0 / size, 1.0);
			return std::pair{x1, x2};
		};

		unsigned size_azi = _pattern.size();
		unsigned size_elev = _pattern[0].size();

		LOG(logging::Level::TRACE, "Size of pattern: {} x {}", size_azi, size_elev);

		const auto [x1, x2] = calc_grid_point(ex1, size_azi);
		const auto [y1, y2] = calc_grid_point(ey1, size_elev);

		const double t = (ex1 - x1) / (x2 - x1);
		const double u = (ey1 - y1) / (y2 - y1);

		const auto calc_array_index = [](const double value, const unsigned size)
		{ return std::min(static_cast<unsigned>(std::floor(value * size)), size - 1); };

		const unsigned arr_x = calc_array_index(x1, size_azi);
		const unsigned arr_y = calc_array_index(y1, size_elev);

		const RealType interp = (1.0 - t) * (1.0 - u) * _pattern[arr_x][arr_y] +
			t * (1.0 - u) * _pattern[(arr_x + 1) % size_azi][arr_y] +
			t * u * _pattern[(arr_x + 1) % size_azi][(arr_y + 1) % size_elev] +
			(1.0 - t) * u * _pattern[arr_x][(arr_y + 1) % size_elev];

		return interp * getEfficiencyFactor();
	}
}
