src/rsdsp.h
//Digital Signal Processing support functions
//Marc Brooker mbrooker@rrsg.ee.uct.ac.za
//30 July 2007

#ifndef __RS_DSP_H
#define __RS_DSP_H

#include <config.h>
#include <boost/utility.hpp>
#include <vector>
#include <complex>
#include <map>
#include "rsradarwaveform.h"

namespace rs {

  //
  // Support functions
  //

  /// Upsample size samples stored *in by an integer ratio and store the result in (pre-allocated) out
  void Upsample(const rsComplex *in, int size, rsComplex *out, int ratio);
  /// Downsample size samples stored *in by an integer ratio and store the result in (pre-allocated) out
  void Downsample(const rsComplex *in, int size, rsComplex *out, int ratio);

  /// Filter, parent class for digital filters
  class DSPFilter: boost::noncopyable {
  public:
    /// Constructor
    DSPFilter();
    /// Destructor
    virtual ~DSPFilter();
    /// Pass a single sample through the filter
    virtual rsFloat Filter(rsFloat sample) = 0;
    /// Pass an array of samples through the filter, filtering in place
    virtual void Filter(rsFloat *samples, int size) = 0;
  };

  /// IIR (ARMA) Digital Filter, implemented with Direct Form II
  // Supports filters of the type A(z)/B(z)
  class IIRFilter: public DSPFilter {
  public:
    /// Constructor
    IIRFilter(const std::vector<rsFloat> &den_coeffs, const std::vector<rsFloat> &num_coeffs);
    /// Constuctor
    IIRFilter(const rsFloat *den_coeffs, const rsFloat *num_coeffs, unsigned int order);
    /// Destructor
    virtual ~IIRFilter();
    /// Pass a single sample through the filter
    virtual rsFloat Filter(rsFloat sample);
    /// Pass an array of samples through the filter, filtering in place
    virtual void Filter(rsFloat *samples, int size);
  private:
    rsFloat *w; //!< Past x values
    //    rsFloat *wy; //!< Past y values
    rsFloat *a; //!< Denominator co-efficients
    rsFloat *b; //!< Numerator co-efficients
    unsigned int order; //!< Filter order
  };

  /// FIR (MA) Digital Filter
  //Supports filters of the type B(z)/1
  class FIRFilter: public DSPFilter {
  public:
    /// Constructor
    FIRFilter(const std::vector<rsFloat> &coeffs);
    FIRFilter(const rsFloat* coeffs, int count);
    /// Destructor
    virtual ~FIRFilter();
    /// Pass a single sample through the filter
    virtual rsFloat Filter(rsFloat sample);
    /// Pass an array of samples through the filter, filtering in place
    virtual void Filter(rsFloat *samples, int size);
    /// Pass an array of complex samples through the filter, filtering in place
    void Filter(std::complex<rsFloat> *samples, int size);
  private:
    rsFloat *w; //!< Filter state
    rsFloat *filter; //!< Filter coefficients
    unsigned int order; //!< Filter order
  };

  /// Auto Regressive (AR) Digital Filter
  //Supports filters of the type 1/A(z)
  class ARFilter: public DSPFilter {
  public:
    /// Constructor
    ARFilter(const std::vector<rsFloat> &coeffs);
    /// Destructor
    ~ARFilter();
    /// Pass a single sample through the filter
    virtual rsFloat Filter(rsFloat sample);
    /// Pass an array of samples through the filter, filtering in place
    virtual void Filter(rsFloat *samples, int size);
  private:
    rsFloat *w; //!< Filter state
    rsFloat *filter; //!< Filter coefficients
    unsigned int order; //!< Filter order
  };

  /// Upsamples a signal and applies an anti-imaging filter
  // Implemented using polyphase FIR filter with windowed sinc
  class Upsampler: boost::noncopyable {
  public:
    /// Constructor (ratio of upsampling, co-efficients of anti-imaging filter)
    Upsampler(int ratio);
    /// Destructor
    ~Upsampler();
    /// Upsample the given sample to a pre-allocated target
    void Upsample(rsFloat *insamples, int in_size, rsFloat *outsamples, int out_size);
  private:
    int ratio; //!< Upsampling ratio
    rsFloat *filterbank; //!< FIR polyphase filter bank
    rsFloat *sample_memory; //!< Last samples used, to allow seamless upsampling in blocks
    int filter_size; //!< Length of the interpolation filter
    //Get a sample, from either the provided pointer or sample memory
    inline rsFloat GetSample(rsFloat *samples, int n);
  };

  /// Upsample a signal by a factor of 10
  class DecadeUpsampler: boost::noncopyable {
  public:
    /// Constructor
    DecadeUpsampler();
    /// Destrubtor
    ~DecadeUpsampler();
    /// Upsample one sample at a time, out is array of ten samples
    void Upsample(rsFloat sample, rsFloat *out);
    /// Upsample a large block, out must be ten times bigger than in
    void Upsample(rsFloat *in, int count, rsFloat *out);
  private:
    /// Anti-imaging filter
    IIRFilter *filter;
  };
};

#endif


src/rsantenna.cpp
//rsantenna.cpp
//Implementation of Antenna Class
//Marc Brooker mbrooker@rrsg.ee.uct.ac.za
//20 July 2006

#define TIXML_USE_STL //Tell tinyxml to use the STL instead of it's own string class

#include <stdexcept>
#include <algorithm>
#include "rsantenna.h"
#include "rsdebug.h"
#include <cmath>
#include "rsportable.h"
#include "rsinterp.h"
#include <tinyxml.h>
#include "rspattern.h"
#include "rsradarwaveform.h"

using namespace rs;
using namespace rsAntenna;

//One of the xml utility functions from xmlimport.cpp
rsFloat GetNodeFloat(TiXmlHandle &node);

namespace {
  //Return sin(x)/x
  rsFloat sinc(rsFloat theta)
  {
    return std::sin(theta)/(theta+std::numeric_limits<rsFloat>::epsilon());
  }

  //Return the first order, first kind bessel function of x, divided by x
  rsFloat j1c(rsFloat x)
  {
    if (x == 0)
      return 1;
    return rsPortable::BesselJ1(x)/(x);
  }
}

//Default constructor for the antenna
Antenna::Antenna(const std::string& name):
  lossFactor(1), //Antenna efficiency default is unity
  name(name)
{
}

//Antenna destructor
Antenna::~Antenna()
{
}

//Set the efficiency factor of the antenna
void Antenna::SetEfficiencyFactor(rsFloat loss)
{
  if (loss > 1)
    rsDebug::printf(rsDebug::RS_IMPORTANT, "Using greater than unity antenna efficiency, results might be inconsistent with reality.\n");
  lossFactor = loss;
}

//Get the efficiency factor
rsFloat Antenna::GetEfficiencyFactor() const
{
  return lossFactor;
}

//Return the name of the antenna
std::string Antenna::GetName() const
{
  return name;
}

// Get the angle (in radians) off boresight
rsFloat Antenna::GetAngle(const SVec3 &angle, const SVec3 &refangle) const
{
  //Get the angle off boresight
  SVec3 normangle(angle);
  normangle.length = 1;
  Vec3 cangle(normangle);
  Vec3 ref(refangle);
  return std::acos(DotProduct(cangle, ref));
}

/// Get the noise temperature of the antenna in a particular direction
rsFloat Antenna::GetNoiseTemperature(const SVec3 &angle) const
{
  return 0; //TODO: Antenna noise temperature calculation
}

//
//Isotropic Implementation
//

//Default constructor
Isotropic::Isotropic(const std::string& name):
  Antenna(name)
{
}

//Default destructor
Isotropic::~Isotropic()
{
}

//Return the gain of the antenna
rsFloat Isotropic::GetGain(const SVec3 &angle, const SVec3 &refangle, rsFloat wavelength) const
{
  return GetEfficiencyFactor();
}

//
// Gaussian Implementation
//


/// Constructor
Gaussian::Gaussian(const std::string& name, rsFloat azscale, rsFloat elscale):
  Antenna(name),
  azscale(azscale),
  elscale(elscale)
{

}

/// Destructor
Gaussian::~Gaussian()
{
}

/// Get the gain at an angle
rsFloat Gaussian::GetGain(const rs::SVec3 &angle, const rs::SVec3 &refangle, rsFloat wavelength) const
{
  SVec3 a = angle - refangle;
  rsFloat azfactor = std::exp(-a.azimuth*a.azimuth*azscale);
  rsFloat elfactor = std::exp(-a.elevation*a.elevation*elscale);
  return azfactor*elfactor;
}


//
//Sinc Implemetation
//

//Constructor
Sinc::Sinc(const std::string& name, rsFloat alpha, rsFloat beta, rsFloat gamma):
  Antenna(name),
  alpha(alpha),
  beta(beta),
  gamma(gamma)
{
}

//Default destructor
Sinc::~Sinc()
{
}

// Return the gain of the antenna at an angle
rsFloat Sinc::GetGain(const SVec3 &angle, const SVec3 &refangle, rsFloat wavelength) const
{
  //Get the angle off boresight
  rsFloat theta = GetAngle(angle, refangle);

  //FIX 2015/02/18 CA Tong:
  //std::pow<double> returns NaN for negative bases with certain fractional indices as they create an uneven
  //root which is, of course, a complex number. Inputs therefore need to be cast to complex numbers before the
  //calculation as this will return complex number. Then return the magnitude as the beam gain.

  rs::rsComplex complexSinc(::sinc(beta*theta), 0.0);
  rs::rsComplex complexGamma(gamma, 0.0);

  //See "Sinc Pattern" in doc/equations.tex for equation used here
  rsComplex complexGain = alpha * std::pow(complexSinc, complexGamma) * GetEfficiencyFactor();

  //rsDebug::printf(rsDebug::RS_IMPORTANT, "Theta = %f Gain = %f, %f\n", theta, complexGain.real(), complexGain.imag());

  return std::abs(complexGain);
}

//
// SquareHorn Implementation
//

//Constructor
SquareHorn::SquareHorn(const std::string& name, rsFloat dimension):
  Antenna(name),
  dimension(dimension)
{
}

//Destructor
SquareHorn::~SquareHorn()
{
}

//Return the gain of the antenna
//See doc/equations.tex for details
rsFloat SquareHorn::GetGain(const SVec3 &angle, const SVec3 &refangle, rsFloat wavelength) const
{
  rsFloat Ge = 4*M_PI*dimension*dimension/(wavelength*wavelength);
  rsFloat x = M_PI*dimension*std::sin(GetAngle(angle, refangle))/wavelength;
  rsFloat gain = Ge*std::pow(::sinc(x), 2);
  return gain*GetEfficiencyFactor();
}


//
// Parabolic Dish Antenna
//

// Constructor
ParabolicReflector::ParabolicReflector(const std::string& name, rsFloat diameter):
  Antenna(name),
  diameter(diameter)
{
}

//Destructor
ParabolicReflector::~ParabolicReflector()
{
}

//Return the gain of the antenna
//See doc/equations.tex for details
rsFloat ParabolicReflector::GetGain(const SVec3 &angle, const SVec3 &refangle, rsFloat wavelength) const
{
  rsFloat Ge = std::pow(M_PI*diameter/wavelength, 2);
  rsFloat x = M_PI*diameter*std::sin(GetAngle(angle, refangle))/wavelength;
  rsFloat gain = Ge*std::pow(2*::j1c(x), 2);
  return gain*GetEfficiencyFactor();
}

//
// FileAntenna implementation
//

/// Constructor
FileAntenna::FileAntenna(const std::string& name, const std::string &filename):
  Antenna(name)
{
  pattern = new Pattern(filename);
}

/// Default destructor
FileAntenna::~FileAntenna()
{
  delete pattern;
}

/// Get the gain at an angle
rsFloat FileAntenna::GetGain(const rs::SVec3 &angle, const rs::SVec3 &refangle, rsFloat wavelength) const
{
  SVec3 a1 = angle;
  SVec3 a2 = refangle;
  SVec3 in_angle = (a1-a2);
  //  rsDebug::printf(rsDebug::RS_VERY_VERBOSE, "az: %g el: %g\t az2: %g el2: %g\t az3: %g el3: %g\n", angle.azimuth, angle.elevation, refangle.azimuth, refangle.elevation, in_angle.azimuth, refangle.elevation);
  return pattern->GetGain(in_angle)*GetEfficiencyFactor();
}

//
// Antenna with pattern loaded from an XML file
//

// Constructor
XMLAntenna::XMLAntenna(const std::string& name, const std::string &filename):
  Antenna(name)
{
  // Classes to interpolate across elevation and azimuth
  azi_samples = new InterpSet();
  elev_samples = new InterpSet();
  //Load the XML antenna description data
  LoadAntennaDescription(filename);
}

//Destructor
XMLAntenna::~XMLAntenna()
{
  // Clean up the interpolation classes
  delete azi_samples;
  delete elev_samples;
}

//Return the gain of the antenna
//See doc/equations.tex for details
rsFloat XMLAntenna::GetGain(const SVec3 &angle, const SVec3 &refangle, rsFloat wavelength) const
{
  SVec3 t_angle = angle-refangle;
  rsFloat azi_gain = azi_samples->Value(std::fabs(t_angle.azimuth));
  rsFloat elev_gain = elev_samples->Value(std::fabs(t_angle.elevation));
  return azi_gain*elev_gain*max_gain*GetEfficiencyFactor();
}

namespace {

//Load samples of gain along an axis (not a member of XMLAntenna)
void LoadAntennaGainAxis(InterpSet *set, TiXmlHandle &axisXML)
{
  rsFloat angle;
  rsFloat gain;
  //Step through the XML file and load all the gain samples
  TiXmlHandle tmp = axisXML.ChildElement("gainsample", 0);
  for (int i = 0; tmp.Element() != 0; i++) {
    //Load the angle of the gain sample
    TiXmlHandle angleXML = tmp.ChildElement("angle", 0);
    if (!angleXML.Element())
      throw std::runtime_error("[ERROR] Misformed XML in antenna description: No angle in gainsample");
    angle = GetNodeFloat(angleXML);
    //Load the gain of the gain sample
    TiXmlHandle gainXML = tmp.ChildElement("gain", 0);
    if (!gainXML.Element())
      throw std::runtime_error("[ERROR] Misformed XML in antenna description: No gain in gainsample");
    gain = GetNodeFloat(gainXML);
    //Load the values into the interpolation table
    set->InsertSample(angle, gain);
    //Get the next gainsample in the file
    tmp = axisXML.ChildElement("gainsample", i);
  }
}

}

//Load the antenna description file
void XMLAntenna::LoadAntennaDescription(const std::string& filename)
{
  TiXmlDocument doc(filename.c_str());
  //Check the document was loaded correctly
  if (!doc.LoadFile())
    throw std::runtime_error("[ERROR] Could not load antenna description "+filename);
  //Get the XML root node
  TiXmlHandle root(doc.RootElement());
  //Load the gain samples along the elevation axis
  TiXmlHandle tmp = root.ChildElement("elevation", 0);
  if (!tmp.Element())
    throw std::runtime_error("[ERROR] Malformed XML in antenna description: No elevation pattern definition");
  LoadAntennaGainAxis(elev_samples, tmp);
  //Load the gain samples along the azimuth axis
  tmp = root.ChildElement("azimuth", 0);
  if (!tmp.Element())
    throw std::runtime_error("[ERROR] Malformed XML in antenna description: No azimuth pattern definition");
  LoadAntennaGainAxis(azi_samples, tmp);
  // Normalize the antenna patterns and calculate the max gain
  max_gain = std::max(azi_samples->Max(), elev_samples->Max());
  elev_samples->Divide(max_gain);
  azi_samples->Divide(max_gain);

}

//
// Antenna with gain pattern calculated by a Python program
//

// Constructor
PythonAntenna::PythonAntenna(const std::string& name, const std::string &module, const std::string& function):
  Antenna(name),
  py_antenna(module, function)
{

}

//Destructor
PythonAntenna::~PythonAntenna()
{
}

//Return the gain of the antenna
rsFloat PythonAntenna::GetGain(const SVec3 &angle, const SVec3 &refangle, rsFloat wavelength) const
{
  SVec3 angle_bore = angle - refangle; //Calculate the angle off boresight
  rsFloat gain = py_antenna.GetGain(angle_bore);
  return gain*GetEfficiencyFactor();
}


//
// Functions to create Antenna objects with a variety of properties
//

//Create an isotropic antenna with the specified name
Antenna* rs::CreateIsotropicAntenna(const std::string &name)
{
  rsAntenna::Isotropic *iso = new rsAntenna::Isotropic(name);
  return iso;
}

//Create a Sinc pattern antenna with the specified name, alpha and beta
Antenna* rs::CreateSincAntenna(const std::string &name, rsFloat alpha, rsFloat beta, rsFloat gamma)
{
  rsAntenna::Sinc *sinc = new rsAntenna::Sinc(name, alpha, beta, gamma);
  return sinc;
}

//Create a Gaussian pattern antenna
Antenna* rs::CreateGaussianAntenna(const std::string &name, rsFloat azscale, rsFloat elscale)
{
  rsAntenna::Gaussian *gau = new rsAntenna::Gaussian(name, azscale, elscale);
  return gau;
}

//Create a square horn antenna
Antenna* rs::CreateHornAntenna(const std::string &name, rsFloat dimension)
{
  rsAntenna::SquareHorn *sq = new rsAntenna::SquareHorn(name, dimension);
  return sq;
}

//Create a parabolic reflector antenna
Antenna* rs::CreateParabolicAntenna(const std::string &name, rsFloat diameter)
{
  rsAntenna::ParabolicReflector *pd = new rsAntenna::ParabolicReflector(name, diameter);
  return pd;
}

//Create an antenna with it's gain pattern stored in an XML file
Antenna* rs::CreateXMLAntenna(const std::string &name, const std::string &file)
{
  rsAntenna::XMLAntenna *fa = new rsAntenna::XMLAntenna(name, file);
  return fa;
}

//Create an antenna with it's gain pattern stored in an XML file
Antenna* rs::CreateFileAntenna(const std::string &name, const std::string &file)
{
  rsAntenna::FileAntenna *fa = new rsAntenna::FileAntenna(name, file);
  return fa;
}

//Create an antenna with gain pattern described by a Python program
Antenna* rs::CreatePythonAntenna(const std::string &name, const std::string &module, const std::string &function)
{
  rsAntenna::PythonAntenna* pa = new rsAntenna::PythonAntenna(name, module, function);
  return pa;
}


src/rsantenna.h
//rsantenna.h
//Class for Antennas, with different gain patterns, etc
//Marc Brooker mbrooker@rrsg.ee.uct.ac.za
//20 July 2006

#ifndef __RSANTENNA_H
#define __RSANTENNA_H

#include <config.h>
#include <string>
#include "rsgeometry.h"
#include "boost/utility.hpp"
#include "rspython.h"
#include <limits>

namespace rs {
  //Forward declaration of SVec3 and Vec3 (see rspath.h)
  class SVec3;
  class Vec3;
  //Forward declaration of InterpSet (see rsinterp.h)
  class InterpSet;
  //Forward declaration of Pattern (see rspattern.h)
  class Pattern;

  /// The antenna class defines an antenna, which may be used by one or more transmitters
  class Antenna: public boost::noncopyable { //Antennas are not meant to be copied
  public:
    /// Default constructor
    Antenna(const std::string& name);
    /// Destructor
    virtual ~Antenna();
    /// Returns the current gain at a particular angle
    virtual rsFloat GetGain(const SVec3& angle, const SVec3& refangle, rsFloat wavelength) const = 0;
    /// Returns the noise temperature at a particular angle
    virtual rsFloat GetNoiseTemperature(const SVec3& angle) const;
    /// Set the antenna's loss factor (values > 1 are physically impossible)
    void SetEfficiencyFactor(rsFloat loss);
    /// Gets the Loss Factor
    rsFloat GetEfficiencyFactor() const;
    /// Return the name of the antenna
    std::string GetName() const;
  protected:
    /// Get the angle off boresight
    rsFloat GetAngle(const SVec3 &angle, const SVec3 &refangle) const;
  private:
    /// The loss factor for this antenna
    rsFloat lossFactor; //!< Loss factor
    /// The name of the antenna
    std::string name;
  };

  // Functions to create Antenna objects

  /// Create an Isotropic Antenna
  Antenna* CreateIsotropicAntenna(const std::string &name);

  /// Create an antenna with it's gain pattern stored in an XML file
  Antenna* CreateXMLAntenna(const std::string &name, const std::string &file);

  /// Create an antenna with it's gain pattern stored in an HDF5 file
  Antenna* CreateFileAntenna(const std::string &name, const std::string &file);

  /// Create an antenna with gain pattern described by a Python program
  Antenna* CreatePythonAntenna(const std::string &name, const std::string &module, const std::string &function);

  /// Create a Sinc Pattern Antenna
  // see rsantenna.cpp for meaning of alpha and beta
  Antenna* CreateSincAntenna(const std::string &name, rsFloat alpha, rsFloat beta, rsFloat gamma);

  /// Create a Gaussian Pattern Antenna
  Antenna* CreateGaussianAntenna(const std::string &name, rsFloat azscale, rsFloat elscale);

  /// Create a Square Horn Antenna
  Antenna* CreateHornAntenna(const std::string &name, rsFloat dimension);

  /// Create a parabolic reflector dish
  Antenna* CreateParabolicAntenna(const std::string &name, rsFloat diameter);

}

namespace rsAntenna {

  //Antenna with an Isotropic radiation pattern
  class Isotropic: public rs::Antenna {
  public:
    /// Default constructor
    Isotropic(const std::string& name);
    /// Default destructor
    virtual ~Isotropic();
    /// Get the gain at an angle
    virtual rsFloat GetGain(const rs::SVec3 &angle, const rs::SVec3 &refangle, rsFloat wavelength) const;
  };

  //Antenna with a sinc (sinx/x) radiation pattern
  class Sinc: public rs::Antenna {
  public:
    /// Constructor
    Sinc(const std::string& name, rsFloat alpha, rsFloat beta, rsFloat gamma);
    /// Destructor
    virtual ~Sinc();
    /// Get the gain at an angle
    virtual rsFloat GetGain(const rs::SVec3 &angle, const rs::SVec3 &refangle, rsFloat wavelength) const;
  private:
    rsFloat alpha; //!< First parameter (see equations.tex)
    rsFloat beta; //!< Second parameter (see equations.tex)
    rsFloat gamma; //!< Third parameter (see equations.tex)
  };

  //Antenna with a Gaussian radiation pattern
  class Gaussian: public rs::Antenna {
  public:
    /// Constructor
    Gaussian(const std::string& name, rsFloat azscale, rsFloat elscale);
    /// Destructor
    virtual ~Gaussian();
    /// Get the gain at an angle
    virtual rsFloat GetGain(const rs::SVec3 &angle, const rs::SVec3 &refangle, rsFloat wavelength) const;
  private:
    rsFloat azscale; //!< Azimuth scale parameter
    rsFloat elscale; //!< Elevation scale parameter
  };

  /// Square horn antenna
  class SquareHorn: public rs::Antenna {
  public:
    /// Constructor
    SquareHorn(const std::string& name, rsFloat dimension);
    /// Default destructor
    ~SquareHorn();
    /// Get the gain at an angle
    rsFloat GetGain(const rs::SVec3 &angle, const rs::SVec3 &refangle, rsFloat wavelength) const;
  private:
    rsFloat dimension; //!< The linear size of the horn
  };

  /// Parabolic dish antenna
  class ParabolicReflector: public rs::Antenna {
  public:
    /// Constructor
    ParabolicReflector(const std::string& name, rsFloat diameter);
    /// Default destructor
    ~ParabolicReflector();
    /// Get the gain at an angle
    rsFloat GetGain(const rs::SVec3 &angle, const rs::SVec3 &refangle, rsFloat wavelength) const;
  private:
    rsFloat diameter;
  };

  /// Antenna with gain pattern loaded from and XML description file
  class XMLAntenna: public rs::Antenna {
  public:
    /// Constructor
    XMLAntenna(const std::string& name, const std::string &filename);
    /// Default destructor
    ~XMLAntenna();
    /// Get the gain at an angle
    rsFloat GetGain(const rs::SVec3 &angle, const rs::SVec3 &refangle, rsFloat wavelength) const;
  private:
    /// Load data from the antenna description file
    void LoadAntennaDescription(const std::string& filename);
    rsFloat max_gain; //!< Maximum Antenna gain
    rs::InterpSet* azi_samples; //!< Samples in the azimuth direction
    rs::InterpSet* elev_samples; //!< Samples in the elevation direction
  };

  /// Antenna with gain pattern loaded from an HDF5 2D pattern (as made by antennatool)
  class FileAntenna: public rs::Antenna {
  public:
    /// Constructor
    FileAntenna(const std::string& name, const std::string &filename);
    /// Default destructor
    ~FileAntenna();
    /// Get the gain at an angle
    rsFloat GetGain(const rs::SVec3 &angle, const rs::SVec3 &refangle, rsFloat wavelength) const;
  private:
    /// The antenna gain pattern
    rs::Pattern *pattern;
  };

  /// Antenna with gain pattern calculated by a Python module
  class PythonAntenna: public rs::Antenna {
  public:
    /// Constructor
    PythonAntenna(const std::string& name, const std::string &module, const std::string& function);
    /// Default destructor
    ~PythonAntenna();
    /// Get the gain at an angle
    rsFloat GetGain(const rs::SVec3 &angle, const rs::SVec3 &refangle, rsFloat wavelength) const;
  private:
    rsPython::PythonAntennaMod py_antenna;
  };

}

#endif


src/rssignal.cpp
//rssignal.cpp - Class to contain an arbitrary frequency domain signal
//Marc Brooker mbrooker@rrsg.ee.uct.ac.za
//24 May 2006

#include <cmath>
#include <limits>
#include <stdexcept>
#include <boost/thread/mutex.hpp>

#include "rssignal.h"
#include "rsdebug.h"
#include "rsnoise.h"
#include "rsparameters.h"
#include "rsdsp.h"
#include "rsportable.h"

using namespace rsSignal;
using namespace rs;
//Global mutex to protect the InterpFilter filter calculation function
boost::mutex interp_mutex;

namespace
{

  /// Compute the zeroth order modified bessel function of the first kind
  // Use the polynomial approximation from section 9.8 of
  // "Handbook of Mathematical Functions" by Abramowitz and Stegun
  rsFloat
  BesselI0(rsFloat x)
  {
    rsFloat I0;
    rsFloat t = (x / 3.75);
    if (t < 0.0)
    {
      throw std::logic_error("Modified Bessel approximation only valid for x > 0");
    }
    else if (t <= 1.0)
    {
      t *= t;
      I0 = 1.0 + t * (3.5156229 + t * (3.0899424 + t * (1.2067492 + t * (0.2659732 + t * (0.0360768 + t * 0.0045813)))));
      //Error bounded to 1.6e-7
    }
    else
    { //t > 1;
      I0 = 0.39894228
          + t
              * (0.01328592
                  + t * (0.00225319 + t * (-0.00157565 + t * (0.00916281 + t * (-0.02057706 + t * (0.02635537 + t * (-0.01647633 + t * 0.00392377)))))));
      I0 *= std::exp(x) / std::sqrt(x);
      //Error bounded to 1.9e-7
    }
    return I0;
  }

  class InterpFilter
  {
    public:
      /// Compute the sinc function at the specified x
      inline rsFloat
      Sinc(rsFloat x) const;
      /// Compute the value of a Kaiser Window at the given x
      inline rsFloat
      kaiser_win_compute(rsFloat x) const;
      /// Calculate the value of the interpolation filter at time x
      inline rsFloat
      interp_filter(rsFloat x) const;
      /// Get a pointer to the filter with approximately the specified delay
      const rsFloat*
      GetFilter(rsFloat delay) const;
      /// Get a pointer to the class instance
      static InterpFilter*
      GetInstance()
      {
        // Protect this with a mutex --- all other operations are const
        boost::mutex::scoped_lock lock(interp_mutex);
        if (!instance)
          instance = new InterpFilter();
        return instance;
      }
    private:
      //// Default constructor
      InterpFilter();
      /// Copy Constructor
      InterpFilter(const InterpFilter& ifilt);
      /// Assignment operator
      InterpFilter&
      operator=(const InterpFilter& ifilt);
      /// Pointer to a single instance of the class
      static InterpFilter *instance;

      rsFloat alpha; //!< 'alpha' parameter
      rsFloat beta; //!< 'beta' parameter
      rsFloat bessel_beta; //!< I0(beta)
      int length;
      int table_filters; //!< Number of filters in the filter table
      rsFloat *filter_table; //!< Table of precalculated filters
  };

  /// Interpfilter class constructor
  InterpFilter::InterpFilter()
  {
    length = rsParameters::render_filter_length();
    //Size of the table to use for interpolation
    table_filters = 1000;
    //Allocate memory for the table
    filter_table = new rsFloat[table_filters * length];
    //Alpha is half the filter length
    alpha = std::floor(rsParameters::render_filter_length() / 2.0);
    //Beta sets the window shape
    beta = 5;
    bessel_beta = BesselI0(beta);
    int hfilt = table_filters / 2;
    rsDebug::printf(rsDebug::RS_VERY_VERBOSE, "[VV] Building table of %d filters\n", table_filters);
    //Fill the table of filters
    //C Tong: delay appears to be the fraction of time ellapsed between samples
    for (int i = -hfilt; i < hfilt; i++)
    {
      rsFloat delay = i / rsFloat(hfilt);
      for (int j = -alpha; j < alpha; j++)
      {
        filter_table[int((i + hfilt) * length + j + alpha)] = interp_filter(j - delay);
      }
    }
    rsDebug::printf(rsDebug::RS_VERY_VERBOSE, "[VV] Filter table complete.\n");
  }

  /// Get a pointer to the filter with approximately the specified delay
  const rsFloat*
  InterpFilter::GetFilter(rsFloat delay) const
  {
    int filt = (delay + 1) * (table_filters / 2);

    if ((delay <= -1) || (delay >= 1))
    {
      rsDebug::printf(rsDebug::RS_VERY_VERBOSE, "GetFilter %f %d\n", delay, filt);
      throw std::runtime_error("[BUG] Requested delay filter value out of range");
    }

    //rsDebug::printf(rsDebug::RS_VERY_VERBOSE, "GetFilter %f %d\n", delay, filt);
    return &(filter_table[filt * length]);
  }

  /// Lookup the value of the interpolation filter at time x
  rsFloat
  InterpFilter::interp_filter(rsFloat x) const
  {
    rsFloat w = kaiser_win_compute(x + alpha);
    rsFloat s = Sinc(x); //The filter value
    rsFloat filt = w * s;
    //      rsDebug::printf(rsDebug::RS_VERY_VERBOSE, "%g %g\n", t, filt);
    return filt;
  }

  /// Compute the sinc function at the specified x
  rsFloat
  InterpFilter::Sinc(rsFloat x) const
  {
    if (x == 0)
      return 1.0;
    return std::sin(x * M_PI) / (x * M_PI);
  }

  /// Compute the value of a Kaiser Window at the given x
  rsFloat
  InterpFilter::kaiser_win_compute(rsFloat x) const
  {
    if ((x < 0) || (x > (alpha * 2)))
      return 0;
    else
      return BesselI0(beta * std::sqrt(1 - std::pow((x - alpha) / alpha, 2))) / bessel_beta;
  }

  //Create an instance of InterpFilter
  InterpFilter* InterpFilter::instance = 0;

}

/// Simulate the effect of and ADC converter on the signal
void
rsSignal::ADCSimulate(complex *data, unsigned int size, int bits, rsFloat fullscale)
{
  //Get the number of levels associated with the number of bits
  rsFloat levels = pow(2, bits - 1);
  for (unsigned int i = 0; i < size; i++)
  {
    //Simulate the ADC effect on the I and Q samples
    rsFloat I = std::floor(levels * data[i].real() / fullscale) / levels;
    rsFloat Q = std::floor(levels * data[i].imag() / fullscale) / levels;
    //Clamp I and Q to the range, simulating saturation in the adc
    if (I > 1)
      I = 1;
    else if (I < -1)
      I = -1;
    if (Q > 1)
      Q = 1;
    else if (Q < -1)
      Q = -1;
    //Overwrite data with the results
    data[i] = complex(I, Q);
  }
}

//
// Signal Implementation
//

//Default constructor for brute signal
Signal::Signal() :
    data(0), size(0), rate(0)
{
}

//Default destructor for brutesignal
Signal::~Signal()
{
  delete[] data;
}

//Clear the data array, emptying the signal and freeing memory
void
Signal::Clear()
{
  delete[] data;
  size = 0;
  rate = 0;
  data = 0; //Set data to zero to prevent multiple frees
}

//Load data into the signal, with the given sample rate and size
void
Signal::Load(const rsFloat *indata, unsigned int samples, rsFloat samplerate)
{
  //Remove the previous data
  Clear();
  //Set the size and samples attributes
  size = samples;
  rate = samplerate;
  //Allocate memory for the signal
  data = new complex[samples];
  //Copy the data
  for (unsigned int i = 0; i < samples; i++)
    data[i] = complex(indata[i], 0.0);
}

/// Load data into the signal (time domain, complex)
void
Signal::Load(const complex *indata, unsigned int samples, rsFloat samplerate)
{
  //Remove the previous data
  Clear();
  // Get the oversampling ratio
  unsigned int ratio = rsParameters::oversample_ratio();
  //Allocate memory for the signal
  data = new complex[samples * ratio];
  //Set the size and samples attributes
  size = samples * ratio;
  rate = samplerate * ratio;
  if (ratio == 1)
  {
    //Copy the data (using a loop for now, not sure memcpy() will always work on complex)
    for (unsigned int i = 0; i < samples; i++)
      data[i] = indata[i];
  }
  else
  {
    // Upsample the data into the target buffer
    Upsample(indata, samples, data, ratio);
  }
}

//Return the sample rate of the signal
rsFloat
Signal::Rate() const
{
  return rate;
}

//Return the size, in samples, of the signal
unsigned int
Signal::Size() const
{
  return size;
}

/// Get a copy of the signal domain data
rsFloat*
Signal::CopyData() const
{
  rsFloat* result = new rsFloat[size];
  //Copy the data into result
  std::memcpy(result, data, sizeof(rsFloat) * size);
  return result;
}

/// Get the number of samples of padding at the beginning of the pulse
unsigned int
Signal::Pad() const
{
  return pad;
}

/// Render the pulse with the specified doppler, delay and amplitude
boost::shared_array<rsComplex>
Signal::Render(const std::vector<InterpPoint> &points, rsFloat trans_power, unsigned int &out_size, rsFloat frac_win_delay) const
{
  //Allocate memory for rendering
  rsComplex *out = new rsComplex[size];
  out_size = size;

  //Get the sample interval
  rsFloat timestep = 1.0 / rate;
  //Create the rendering window
  const int filt_length = rsParameters::render_filter_length();
  InterpFilter* interp = InterpFilter::GetInstance();
  //Loop through the interp points, rendering each in time
  std::vector<rs::InterpPoint>::const_iterator iter = points.begin();
  std::vector<rs::InterpPoint>::const_iterator next = iter + 1;
  if (next == points.end())
    next = iter;

  //Get the delay of the first point
  //C Tong: iDelay is in number of receiver samples (possibly with a fractional part)
  rsFloat idelay = rsPortable::rsRound(rate * (*iter).delay);
  //rsDebug::printf(rsDebug::RS_VERY_VERBOSE, "idelay = %g\n", idelay);

  //Memory to store the filter in
  const rsFloat *filt;

  //Loop over the pulse, performing the rendering
  rsFloat sample_time = (*iter).time;
  for (int i = 0; i < (int) size; i++, sample_time += timestep)
  {
    //Check if we should move on to the next set of interp points
    if ((sample_time > (*next).time))
    {
      iter = next;
      if ((next + 1) != points.end())
        next++;
    }
    //Get the weightings for the parameters
    rsFloat aw = 1, bw = 0;
    if (iter < next)
    {
      bw = (sample_time - (*iter).time) / ((*next).time - (*iter).time);
      aw = 1 - bw;

      //**C Tong:**
      //bw is fraction of time elapsed between 2 samples (this is interpolated)
      //aw is then the fraction of time remaining
    }

    //Now calculate the current sample parameters
    rsFloat amplitude = std::sqrt((*iter).power) * aw + std::sqrt((*next).power) * bw;
    rsFloat phase = (*iter).phase * aw + (*next).phase * bw;
    rsFloat fdelay = -(((*iter).delay * aw + (*next).delay * bw) * rate - idelay + frac_win_delay);

    //if ((*iter).delay * 299792458 != 11000)
    //{
    //rsDebug::printf(rsDebug::RS_VERY_VERBOSE, "%g\n", frac_win_delay);
    //rsDebug::printf(rsDebug::RS_VERY_VERBOSE, "time = %gs, fdelay = %g, range = : %gm\n", (*iter).time, fdelay, (*iter).delay * 299792458);
    //rsDebug::printf(rsDebug::RS_VERY_VERBOSE, "Amp: %g Delay: %g + %g Phase: %g\n", amplitude, (*iter).delay, fdelay, phase);
    //}

    //C Tong: Fixing the |fdelay| > 1 problem.
    //Tx samples and Rx samples are matched 1 to 1 in time pulse the addition of
    //the fraction delay filters to create the delay effect.
    //For long pulses or CW when in there are fast moving targets present
    //the fractional delay can go 1 whole sample which will crash the program.

    //As a fix this we need to look for this "wrapping" effect and
    //unwrap it by using the previous or next sample from the Tx signal.
    //This is a hack at best and the program should really be re-designed.

    int iSampleUnwrap = floor(fdelay); //Number of samples to unwrap by.
    fdelay -= iSampleUnwrap; //Re-calculate the delay filter for the given delay

    filt = interp->GetFilter(fdelay);

    //Get the start and end times of interpolation
    int start = -filt_length / 2;
    if ((i + start) < 0)
      start = -i;

    int end = filt_length / 2;
    if ((i + end) >= size)
      end = size - i;

    //Apply the filter
    complex accum = 0;

    for (int j = start; j < end; j++)
    {
      //Check that unwrapping doesn't put us out of bounds.
      if (i + j + iSampleUnwrap >= size || i + j + iSampleUnwrap < 0)
        continue;

      accum += amplitude * data[i + j + iSampleUnwrap] * filt[j + filt_length / 2]; //Apply unwrapping to Tx samples.
      if (std::isnan(data[j].real()))
        throw std::runtime_error("NAN in Render: data[j].r");
      if (std::isnan(data[j].imag()))
        throw std::runtime_error("NAN in Render: data[j].i");
      if (std::isnan(filt[j - start]))
        throw std::runtime_error("NAN in Render: filt");
    }
    //rsDebug::printf(rsDebug::RS_VERY_VERBOSE, "Out = %g %g\n", accum.real(), accum.imag());

    //Perform IQ demodulation
    rs::rsComplex ph = exp(rs::rsComplex(0.0, 1.0) * phase);
    out[i] = ph * accum;
  }
  //Return the result
  return boost::shared_array<rs::rsComplex>(out);
}



src/rsdsp.cpp
//Digital Signal Processing support functions
//Marc Brooker mbrooker@rrsg.ee.uct.ac.za
//30 July 2007

#include "rsdsp.h"
using namespace rs;

#include <stdexcept>
#include <cmath>
#include <cstring>
#include <string.h>
#include "rsdebug.h"
#include "rsparameters.h"

//
// Support Functions
//
namespace {
  //Calculate sin(pi * x) / (pi*x)
  rsFloat Sinc(rsFloat x) {
    if (x == 0)
      return 1.0;
    return std::sin(x*M_PI)/(x*M_PI);
  }

  /// Create a FIR filter using the Blackman window
  rsFloat *BlackmanFIR(rsFloat cutoff, int &length) {
    // Use double the render filter length, for faster rolloff than the render filter
    length = rsParameters::render_filter_length() * 2;
    rsFloat *coeffs = new rsFloat[length];
    rsFloat N = length / 2.0;
    for (int i = 0; i < length; i++) {
      rsFloat filt = Sinc(cutoff*(i - N));
      // We use the Blackman window, for a suitable tradeoff between rolloff and stopband attenuation
      // Equivalent Kaiser beta = 7.04 (Oppenhiem and Schaffer, Hamming)
      rsFloat window = 0.42 - 0.5*cos(M_PI*i/N) + 0.08*cos(2*M_PI*i/N);
      coeffs[i] = filt*window;
    }
    return coeffs;
  }
}

/// Upsample size samples stored *in by an integer ratio and store the result in (pre-allocated) out
// TODO: this would be better as a multirate upsampler
// In fact, the whole scheme is currently sub-optimal - we could use better filters, better windows and a better approach
// it works ok for now, users seeking higher accuracy can oversample outside FERS until this is fixed
void rs::Upsample(const rsComplex *in, int size, rsComplex *out, int ratio)
{
  /// Design the FIR filter for de-imaging
  int filt_length;
  rsFloat *coeffs = BlackmanFIR(1/rsFloat(ratio), filt_length);

  // Temporary buffer for zero padding and results
  rsComplex *tmp = new rsComplex[size*ratio+filt_length];
  for (int i = 0; i < size*ratio+filt_length; i++)
    tmp[i] = 0;
  /// Stuff the data with a suitable number of zeros
  for (int i = 0; i < size; i++) {
    tmp[i*ratio] = in[i];
    for (int j = 1; j < (ratio-1); j++)
      tmp[i*ratio+j] = 0;
  }
  // Create a FIR filter object
  FIRFilter filt(coeffs, filt_length);
  filt.Filter(tmp, size*ratio+filt_length);
  // Copy results to output buffer
  for (int i = 0; i < size*ratio; i++) {
    out[i] = tmp[i+filt_length/2-1];
  }
  // Clean up
  delete[] tmp;
  delete[] coeffs;

}

/// Upsample size samples stored *in by an integer ratio and store the result in (pre-allocated) out
// TODO: This would be better (and much faster) as a multirate downsampler
void rs::Downsample(const rsComplex *in, int size, rsComplex *out, int ratio)
{
  /// Design the FIR filter for anti-aliasing
  int filt_length;
  rsFloat *coeffs = BlackmanFIR(1/rsFloat(ratio), filt_length);
  // Temporary buffer for zero padding and results
  rsComplex *tmp = new rsComplex[size+filt_length];
  for (int i = size-1; i < size+filt_length; i++)
    tmp[i] = 0;
  // Copy the input into the temporary buffer, leaving zero padding at the end
  for (int i = 0; i < size; i++)
    tmp[i] = in[i];
  // Run the anti aliasing filter on the data
  FIRFilter filt(coeffs, filt_length);
  filt.Filter(tmp, size+filt_length);


  //Copy the results to the output buffer
  for (int i = 0; i < size/ratio; i++) {
    out[i] = tmp[i*ratio+filt_length/2]/rsFloat(ratio);
    //    printf("%f+%fi\n", out[i].real(), out[i].imag());
  }
  // Clean up
  delete[] coeffs;
  delete[] tmp;
}

//
// Filter Implementation
//

/// Constructor
DSPFilter::DSPFilter()
{
}

/// Destructor
DSPFilter::~DSPFilter()
{
}

//
// IIRFilter Implementation
//

/// Constructor
IIRFilter::IIRFilter(const std::vector<rsFloat> &den_coeffs, const std::vector<rsFloat> &num_coeffs)
{
  //Get the filter order
  order = den_coeffs.size();
  //Check the filter order
  if (order != num_coeffs.size())
      throw std::logic_error("IIRFilter does not currently support mixed order filters");
  //Allocate memory to store co-efficients and state
  a = new rsFloat[order];
  b = new rsFloat[order];
  w = new rsFloat[order];
  //Load the co-efficients from the vectors into the arrays
  for (unsigned int i = 0; i < order; i++) {
    a[i] = den_coeffs[i];
    b[i] = num_coeffs[i];
    w[i] = 0;
  }
}

/// Constructor
IIRFilter::IIRFilter(const rsFloat *den_coeffs, const rsFloat *num_coeffs, unsigned int order):
  order(order)
{
  a = new rsFloat[order];
  b = new rsFloat[order];
  w = new rsFloat[order];
  // Load the coefficients into the arrays
  for (unsigned int i = 0; i < order; i++) {
    a[i] = den_coeffs[i];
    b[i] = num_coeffs[i];
    w[i] = 0;
  }
}

/// Destructor
IIRFilter::~IIRFilter()
{
  //Clean up the co-efficients and state
  delete[] a;
  delete[] b;
  delete[] w;
}

/// Pass a single sample through the filter
rsFloat IIRFilter::Filter(rsFloat sample)
{
  //Shift the filter state
  for (unsigned int j = order-1; j > 0; j--)
    w[j] = w[j-1];
  // Calculate w[0]
  w[0] = sample;
  for (unsigned int j = 1; j < order; j++)
    w[0] -= a[j]*w[j];
  //Calculate y[n]
  rsFloat out = 0;
  for (unsigned int j = 0; j < order; j++)
    out += b[j]*w[j];
  return out;
}

/// Pass an array of samples through the filter, filtering in place
void IIRFilter::Filter(rsFloat *samples, int size)
{
  for (int i = 0; i < size; i++)
    {
      //Shift the filter state
      for (unsigned int j = order-1; j > 0; j--)
	w[j] = w[j-1];
      // Calculate w[0]
      w[0] = samples[i];
      for (unsigned int j = 1; j < order; j++)
	w[0] -= a[j]*w[j];
      //Calculate y[n]
      samples[i] = 0;
      for (unsigned int j = 0; j < order; j++)
	samples[i] += b[j]*w[j];
    }
}

//
// FIRFilter implementation
//

/// Constructor
FIRFilter::FIRFilter(const std::vector<rsFloat> &coeffs)
{
  //Get the filter order
  order = coeffs.size();
  //Allocate memory to store co-efficients and state
  filter = new rsFloat[order];
  w = new rsFloat[order];
  //Load the co-efficients from the vectors into the arrays
  for (unsigned int i = 0; i < order; i++) {
    filter[i] = coeffs[i];
    w[i] = 0;
  }
}

/// Constructor from coeffs
FIRFilter::FIRFilter(const rsFloat* coeffs, int count) {
  order = count;
  // Allocate memory to store co-efficients and state
  filter = new rsFloat[order];
  w = new rsFloat[order];
  // Load the co-efficients
  for (unsigned int i = 0; i < order; i++) {
    filter[i] = coeffs[i];
    w[i] = 0;
  }
}

/// Destructor
FIRFilter::~FIRFilter()
{
  // Clean up memory
  delete[] filter;
  delete[] w;
}

/// Pass a single sample through the filter
inline rsFloat FIRFilter::Filter(rsFloat sample)
{


  return 0;
}

/// Pass an array of samples through the filter, filtering in place
  // See Oppenheim and Scaffer, section 6.5 "Basic Network Structures for FIR Systems"
// TODO: Implement one of the more efficient FIR filter forms
inline void FIRFilter::Filter(rsFloat *samples, int size)
{
  // Allocate memory for a delay line, equal to the filter length
  rsFloat* line = new rsFloat[order];
  std::memset(line, 0, sizeof(rsFloat)*order);
  // Perform the inplace convolution with the pulse
  for (int i = 0; i < size; i++) {
    line[0] = samples[i];
    rsFloat res = 0;
    for (unsigned int j = 0; j < order; j++)
      res += line[order-j-1]*filter[j];
    samples[i] = res;
    //Move the line over by one sample
    for (int j = order; j > 0; j--)
      line[j] = line[j-1];
  }
  //Clean up
  delete[] line;
}

/// Pass an array of complex samples through the filter, filtering in place
inline void FIRFilter::Filter(std::complex<rsFloat> *samples, int size)
{
  // Allocate memory for a delay line, equal to the filter length
  rsComplex* line = new rsComplex[order];
  for (unsigned int i = 0; i < order; i++)
    line[i] = 0;
  // Perform the inplace convolution with the pulse
  for (int i = 0; i < size; i++) {
    line[0] = samples[i];
    rsComplex res = 0;
    for (unsigned int j = 0; j < order; j++)
      res += line[order-j-1]*filter[j];
    samples[i] = res;
    //Move the line over by one sample
    for (int j = order-1; j > 0; j--)
      line[j] = line[j-1];
  }
  //Clean up
  delete[] line;
}

//
// ARFilter implementation
//


/// Constructor
ARFilter::ARFilter(const std::vector<rsFloat> &coeffs)
{
  //Get the filter order
  order = coeffs.size();
  //Allocate memory to store co-efficients and state
  filter = new rsFloat[order];
  w = new rsFloat[order];
  //Load the co-efficients from the vectors into the arrays
  for (unsigned int i = 0; i < order; i++) {
    filter[i] = coeffs[i];
    w[i] = 0;
  }
}

/// Destructor
ARFilter::~ARFilter()
{
  // Clean up memory
  delete[] filter;
  delete[] w;
}

/// Pass a single sample through the filter
rsFloat ARFilter::Filter(rsFloat sample)
{
  //Shift the filter state
  for (unsigned int j = order-1; j > 0; j--)
    w[j] = w[j-1];
  // Calculate w[0]
  w[0] = sample;
  for (unsigned int j = 1; j < order; j++)
    w[0] -= filter[j]*w[j];
  //Return the output value of the filter
  return w[0];
}

/// Pass an array of samples through the filter, filtering in place
void ARFilter::Filter(rsFloat *samples, int size)
{
  for (int i = 0; i < size; i++)
    {
      //Shift the filter state
      for (unsigned int j = order-1; j > 0; j--)
	w[j] = w[j-1];
      // Calculate w[0]
      w[0] = samples[i];
      for (unsigned int j = 1; j < order; j++)
	w[0] -= filter[j]*w[j];
      //Calculate y[n]
      samples[i] = w[0];
    }
}

//
// Upsampler implementation
//

/// Constructor
Upsampler::Upsampler(int ratio):
  ratio(ratio)
{
  //Create the FIR interpolation filter
  filter_size = 8*ratio+1; // 8*ratio should give adequate performance
  //Allocate memory for the filter bank
  filterbank = new rsFloat[filter_size];
  // Simple windowed sinc filter design procedure
  for (int i = 0; i < filter_size; i++) {
    // The Hamming window provides a solid tradeoff between rolloff and stopband attenuation
    rsFloat window_value = 0.54 - 0.46 * std::cos(2*M_PI*i/(rsFloat)(filter_size));
    rsFloat filter_value = Sinc(1.0/(rsFloat)(ratio)*(i-filter_size/2));
    filterbank[i] = filter_value * window_value;
  }
  //Allocate memory for the sample state
  sample_memory = new rsFloat[filter_size/ratio+1];
  //Clear sample memory to zero
  for (int i = 0; i < filter_size/ratio+1; i++)
    sample_memory[i] = 0;
}

/// Destructor
Upsampler::~Upsampler()
{
  // Clean up filter and state
  delete[] filterbank;
  delete[] sample_memory;
}

//Get a sample, from either the provided pointer or sample memory
inline rsFloat Upsampler::GetSample(rsFloat *samples, int n)
{
 if (n >= 0)
    return samples[n];
  else
    return sample_memory[n+filter_size];
}

/// Upsamples a signal and applies an anti-imaging filter
void Upsampler::Upsample(rsFloat *insamples, int in_size, rsFloat *outsamples, int out_size)
{
  //Check the target array size
  if (out_size != (ratio*in_size))
    throw std::runtime_error("Target array size is not correct in Upsample");
  // Polyphase upsampler implementation
  // See fers_upsample_p.m in the documentation for more details
  // Follows the diagram in section 4.7.4 "Polyphase Implementation of Interpolation Filters" of
  // Discrete Time Signal Processing, 2nd ed., Oppenheim and Schafer
  for (int i = 0, branch = 0; i < in_size; i++, branch++)
    {
      if (branch >= ratio)
	branch = 0;
      outsamples[i] = 0;
      // Apply the branch filter to the data
      for (int j = branch; j < filter_size; j += ratio)
	outsamples[i] += filterbank[j] * GetSample(insamples, i-j/ratio);
    }
  //Update the sample history
  int transfer_size = filter_size/ratio+1;
  if (in_size >= transfer_size)
    memcpy(sample_memory, &(insamples[in_size-transfer_size]), transfer_size*sizeof(rsFloat));
  else {
    // Shift existing samples
    for (int i = 0; i < (transfer_size-in_size); i++)
      sample_memory[i] = sample_memory[i+in_size];
    // Add new samples to the end of the buffer
    for (int i = 0; i < in_size; i++)
      sample_memory[i+transfer_size-in_size] = insamples[i];
  }
}

//
// DecadeUpsample Implementation
//

/// Constructor
DecadeUpsampler::DecadeUpsampler() {

  /// 11th order elliptic lowpass at 0.1fs
  rsFloat den_coeffs[12] = {1.0,
			    -10.301102119865,
			    48.5214567642597,
			    -137.934509572412,
			    262.914952985445,
			    -352.788381841481,
			    340.027874008585,
			    -235.39260470286,
			    114.698499845697,
			    -37.4634653062448,
			    7.38208765922137,
			    -0.664807695826097};

  rsFloat num_coeffs[12] = {   2.7301694322809e-06,
			       -1.8508123430239e-05,
			       5.75739466753894e-05,
			       -0.000104348734423658,
			       0.000111949190289715,
			       -4.9384188225528e-05,
			       -4.9384188225522e-05,
			       0.00011194919028971,
			       -0.000104348734423656,
			       5.75739466753884e-05,
			       -1.85081234302388e-05,
			       2.73016943228086e-06  };
  //Initialize the anti-imaging filter
  filter = new IIRFilter(den_coeffs, num_coeffs, 12);
}

/// Destructor
DecadeUpsampler::~DecadeUpsampler() {
  delete filter;
}


///Upsample a single sample at a time
void DecadeUpsampler::Upsample(rsFloat sample, rsFloat *out)
{
  // Prepare the output array
  out[0] = sample;
  for (int i = 1; i < 10; i++)
    out[i] = 0;
  // Filter in place
  filter->Filter(out, 10);
}

// Upsample a whole batch of samples
void DecadeUpsampler::Upsample(rsFloat *in, int count, rsFloat *out)
{
  /// Prepare the array for filtering
  for (int i = 0; i < count; i++) {
    out[i*10] = in[i];
    for (int j = 1; j < 10; j++)
      out[i*10+j] = 0;
  }
  /// Filter in place
  filter->Filter(out, count*10);
}
